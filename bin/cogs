#!/usr/bin/env node

var _ = require('underscore');
var cogs = require('..');
require('colors').setTheme({info: 'grey', error: 'red', success: 'green'});
var fs = require('fs');
var growl = require('growl');
var optimist = require('optimist');
var path = require('path');
var watchr = require('watchr');

var config = {};
var dependencies = {};

var argv = optimist
  .usage('Usage: $0 input:dir [-p paths][-w paths][-o json][-C file][-cvCg]')
  .options({
    paths: {
      alias: 'p',
      default: process.cwd(),
      type: 'string',
      desc: 'An environment path or comma-separated paths.'
    },
    options: {
      alias: 'o',
      type: 'string',
      desc: 'JSON for options to be passed to processors and compressors.'
    },
    compress: {
      alias: 'c',
      default: false,
      type: 'boolean',
      desc: 'Compress using UglifyJS and CSSO.'
    },
    watch: {
      alias: 'w',
      type: 'string',
      desc: 'A path or comma-separated paths to watch.'
    },
    'ignore-paths': {
      alias: 'i',
      type: 'string',
      desc: 'A path or comma-separated paths to ignore when watching.'
    },
    'ignore-basenames': {
      alias: 'I',
      type: 'string',
      desc: 'A basename regex to ignore when watching (ie \\.css$).'
    },
    verbose: {
      alias: 'v',
      default: false,
      type: 'boolean',
      desc: 'Log build starts, errors and completes in stdout.'
    },
    growl: {
      alias: 'g',
      default: false,
      type: 'boolean',
      desc: 'Use growl notifications for build starts and completes.'
    },
    config: {
      alias: 'C',
      default: 'cogs.json',
      type: 'string',
      desc: 'A config file specifying command line options.'
    },
    fingerprint: {
      alias: 'f',
      type: 'string',
      desc: 'Specify an algorithm (md5, sha1, etc...) to fingerprint files.'
    }
  }).argv;

optimist.check(function () {
  try { config = require(process.cwd() + '/' + argv.config); } catch (er) {}
  argv.paths = config.paths || argv.paths.split(',');
  if (argv.watch) argv.watch = argv.watch.split(',');
  if (argv.options) argv.options = JSON.parse(argv.options);
  _.each(argv, function (val, key) { if (!val) delete argv[key]; });
  config = _.extend({targets: {}}, config, argv);
  if (argv._[0]) {
    var targets = config.targets;
    _.each(argv._[0].split(','), function (target) {
      var split = target.split(':');
      targets[split[0]] = split[1];
    });
  }
  if (!_.size(config.targets)) {
    throw new Error('Please specify an input file.');
  }
}).argv;

cogs.addPaths(config.paths);

if (config.options) {
  var options = config.options;
  for (var steps in options) {
    var val = options[steps];
    steps = steps.split('.');
    var obj = cogs;
    for (var i = 0, l = steps.length - 1; i < l; ++i) obj = obj[steps[i]];
    obj[steps[i]] = val;
  }
}

if (config.compress) {
  cogs.compressors.js = new cogs.UglifyJs();
  cogs.compressors.css = new cogs.Csso();
}

var alert = function (title, message, type) {
  var name = 'cogs';
  var image = __dirname + '/../gfx/' + type + '.png';
  message = message.toString();
  if (config.growl) growl(message, {title: title, name: name, image: image});
  message = ('[' + name + '] ' + title.bold + ' ' + message)[type];
  if (type === 'error') return console.error(message);
  if (config.verbose) console.log(message);
};


var save = function (input, dir, cb) {
  var title = input + ' -> ' + (dir || 'stdout');
  alert(input, "Building...", 'info');
  var done = function (er) {
    var message = er || 'Built in ' + ((new Date() - start) / 1000);
    alert(title, message, er ? 'error' : 'success');
    cb(er);
  };
  var start = new Date();
  cogs.asset(input, function (er, asset) {
    if (!dependencies[input]) dependencies[input] = [asset.abs];
    if (er) return done(er);
    asset.build(function (er) {
      if (er) return done(er);
      dependencies[input] = _.pluck(asset.dependencies, 'abs');
      if (!dir) {
        process.stdout.write(asset.toString());
        return done();
      }
      fs.writeFile(
        path.resolve(process.cwd(), dir, asset.filename(config.fingerprint)),
        asset.toString(),
        done
      );
    });
  });
};

var saveAll = function (__, file) {
  var cb =
    config.watch ?
    function () {} :
    _.after(_.size(config.targets), _.bind(cogs.end, cogs));
  _.each(config.targets, function (dir, input) {
    if (!file || _.contains(dependencies[input], file)) save(input, dir, cb);
  });
};

saveAll();

if (config.watch) {
  watchr.watch({
    ignoreHiddenFiles: true,
    ignorePaths: config['ignore-paths'] && config['ignore-paths'].split(','),
    ignoreCustomPatterns: config['ignore-basenames'] &&
      new RegExp(config['ignore-basenames'], 'i'),
    paths: _.map(config.watch, function (p) { return path.resolve(p); }),
    listener: saveAll
  });
}
