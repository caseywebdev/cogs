#!/usr/bin/env node

var optimist = require('optimist');
var argv = optimist
  .usage('Usage: $0 input:output [-p paths][-w paths][-o json][-C file][-cvCg]')
  .options({
    paths: {
      alias: 'p',
      default: process.cwd(),
      type: 'string',
      desc: 'An environment path or comma-separated paths.'
    },
    options: {
      alias: 'o',
      type: 'string',
      desc: 'JSON for options to be passed to processors and compressors.'
    },
    compress: {
      alias: 'c',
      default: false,
      type: 'boolean',
      desc: 'Compress using UglifyJS and CleanCss (can be changed with -O).'
    },
    watch: {
      alias: 'w',
      type: 'string',
      desc: 'A path or comma-separated paths to watch.'
    },
    'ignore-paths': {
      alias: 'i',
      type: 'string',
      desc: 'A path or comma-separated paths to ignore when watching.'
    },
    'ignore-basenames': {
      alias: 'I',
      type: 'string',
      desc: 'A basename regex to ignore when watching (ie \\.css$).'
    },
    verbose: {
      alias: 'v',
      default: false,
      type: 'boolean',
      desc: 'Log build starts, errors and completes in stdout.'
    },
    growl: {
      alias: 'g',
      default: false,
      type: 'boolean',
      desc: 'Use growl notifications for build starts and completes.'
    },
    config: {
      alias: 'C',
      default: 'cogs.json',
      type: 'string',
      desc: 'A config file specifying command line options.'
    }
  }).argv;

var _ = require('underscore');
var config = {};
optimist.check(function () {
  try { config = require(process.cwd() + '/' + argv.config); }
  catch (er) { config = {}; }
  argv.paths = config.paths || argv.paths.split(',');
  if (argv.watch) argv.watch = argv.watch.split(',');
  if (argv.options) argv.options = JSON.parse(argv.options);
  _.each(argv, function (val, key) { if (!val) delete argv[key]; });
  config = _.extend({targets: {}}, config, argv);
  if (argv._[0]) {
    var targets = config.targets;
    _.each(argv._[0].split(','), function (target) {
      var split = target.split(':');
      targets[split[0]] = split[1];
    });
  }
  if (!_.size(config.targets)) {
    throw new Error('Please specify an input file.');
  }
}).argv;

require('colors').setTheme({info: 'grey', error: 'red', success: 'green'});
var growl = require('growl');
var cogs = require('..');
var path = require('path');
var watchr = require('watchr');

var alert = function (title, message, type) {
  var name = 'cogs';
  var image = (function () {
    switch (type) {
    case 'success':
      return 'node_modules/mocha/images/ok.png';
    case 'error':
      return 'node_modules/mocha/images/error.png';
    }
  })();
  if (config.growl) growl(message, {title: title, name: name, image: image});
  message = ('[' + name + '] ' + title.bold + ' ' + message)[type];
  if (type === 'error') return console.error(message);
  if (config.verbose) console.log(message);
};

var save = function (input, output) {
  var title = input + ' -> ' + (output || 'stdout');
  alert(title, "Building...", 'info');
  var cb = function (er) {
    var end = new Date();
    var duration = (end - start) / 1000;
    if (er) return alert(title, er.message, 'error');
    alert(title, 'Built in ' + duration + 's.', 'success');
  };
  var start = new Date();
  if (output) return cogs.saveAs(input, output, cb);
  cogs.asset(input, function (er, asset) {
    if (er) return cb(er);
    asset.build(function (er) {
      if (er) return cb(er);
      process.stdout.write(asset.toString());
      cb();
    });
  });
};

cogs.addPaths(config.paths);

if (config.options) {
  var options = config.options;
  for (var steps in options) {
    var val = options[steps];
    steps = steps.split('.');
    var obj = cogs;
    for (var i = 0, l = steps.length - 1; i < l; ++i) obj = obj[steps[i]];
    obj[steps[i]] = val;
  }
}

if (config.compress) {
  cogs.compressors.js = new cogs.UglifyJs();
  cogs.compressors.css = new cogs.CleanCss();
}

_.each(config.targets, function (output, input) { save(input, output); });

if (config.watch) {
  watchr.watch({
    ignoreHiddenFiles: true,
    ignorePaths: config['ignore-paths'] && config['ignore-paths'].split(','),
    ignoreCustomPatterns: config['ignore-basenames'] &&
      new RegExp(config['ignore-basenames'], 'i'),
    paths: _.map(config.watch, function (p) { return path.resolve(p); }),
    listener: function (__, file) {
      _.each(config.targets, function (output, input) {
        cogs.asset(input, function (er, asset) {
          asset.dependencies(function (er, dependencies) {
            if (_.contains(_.pluck(dependencies, 'abs'), file)) {
              save(input, output);
            }
          });
        });
      });
    }
  });
}
