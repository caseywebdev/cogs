#!/usr/bin/env node

'use strict';

var _ = require('underscore');
var async = require('async');
var cogs = require('..');
require('colors').setTheme({info: 'grey', error: 'red', success: 'green'});
var fs = require('fs');
var glob = require('glob');
var growl = require('growl');
var optimist = require('optimist');
var path = require('path');
var watchr = require('watchr');

var config = {};
var dependencies = {};

var argv = optimist
  .usage('Usage: $0 glob:dir [-p paths][-w paths][-o json][-C file][-cvCg]')
  .options({
    paths: {
      alias: 'p',
      default: process.cwd(),
      type: 'string',
      desc: 'An environment path or comma-separated paths.'
    },
    options: {
      alias: 'o',
      type: 'string',
      desc: 'JSON for options to be passed to processors and compressors.'
    },
    compress: {
      alias: 'c',
      default: false,
      type: 'boolean',
      desc: 'Compress using UglifyJS and CSSO.'
    },
    watch: {
      alias: 'w',
      type: 'string',
      desc: 'A path or comma-separated paths to watch.'
    },
    'ignore-paths': {
      alias: 'i',
      type: 'string',
      desc: 'A path or comma-separated paths to ignore when watching.'
    },
    'ignore-basenames': {
      alias: 'I',
      type: 'string',
      desc: 'A basename regex to ignore when watching (ie \\.css$).'
    },
    verbose: {
      alias: 'v',
      default: false,
      type: 'boolean',
      desc: 'Log build starts, errors and completes in stdout.'
    },
    growl: {
      alias: 'g',
      default: false,
      type: 'boolean',
      desc: 'Use growl notifications for build starts and completes.'
    },
    config: {
      alias: 'C',
      default: 'cogs.json',
      type: 'string',
      desc: 'A config file specifying command line options.'
    },
    fingerprint: {
      alias: 'f',
      default: false,
      type: 'boolean',
      desc: 'Fingerprint files with their env.algorithm value.'
    },
    'export-fingerprints': {
      alias: 'F',
      type: 'string',
      desc: 'Save a JSON file fingerprinted name mappings.'
    }
  }).argv;

optimist.check(function () {
  try { config = require(process.cwd() + '/' + argv.config); } catch (er) {}
  argv.paths = config.paths || argv.paths.split(',');
  if (argv.watch) argv.watch = argv.watch.split(',');
  if (argv.options) argv.options = JSON.parse(argv.options);
  _.each(argv, function (val, key) { if (!val) delete argv[key]; });
  config = _.extend({targets: {}}, config, argv);
  if (argv._[0]) {
    var targets = config.targets;
    _.each(argv._[0].split(','), function (target) {
      var split = target.split(':');
      targets[split[0]] = split[1];
    });
  }
  if (!_.size(config.targets)) {
    throw new Error('Please specify an input file.');
  }
}).argv;

cogs.addPaths(config.paths);

if (config.options) {
  var options = config.options;
  for (var steps in options) {
    var val = options[steps];
    steps = steps.split('.');
    var obj = cogs;
    for (var i = 0, l = steps.length - 1; i < l; ++i) obj = obj[steps[i]];
    obj[steps[i]] = val;
  }
}

if (config.compress) {
  cogs.compressors.js = new cogs.UglifyJs();
  cogs.compressors.css = new cogs.Csso();
}

var alert = function (title, message, type) {
  var name = 'cogs';
  var image = __dirname + '/../gfx/' + type + '.png';
  message = message.toString();
  if (config.growl) growl(message, {title: title, name: name, image: image});
  message = ('[' + name + '] ' + title.bold + ' ' + message)[type];
  if (type === 'error') return console.error(message);
  if (config.verbose) console.log(message);
};


var save = function (file, src, dir, cb) {
  var title = path.relative('.', file);
  alert(title, 'Building...', 'info');
  var done = function (er) {
    var message = er || 'Built in ' + ((new Date() - start) / 1000) + 's';
    alert(title, message, er ? 'error' : 'success');
    cb(er);
  };
  var start = new Date();
  cogs.asset(file, function (er, asset) {
    if (!dependencies[file]) dependencies[file] = [asset.abs];
    if (er) return done(er);
    asset.build(function (er) {
      if (er) return done(er);
      dependencies[file] = _.pluck(asset.dependencies, 'abs');
      if (!dir) {
        process.stdout.write(asset.toString());
        return done();
      }
      asset.saveToDir(src, dir, config.fingerprint, done);
    });
  });
};

var saveAll = function (__, change) {
  var targets = config.targets;
  async.each(_.keys(targets), function (src, cb) {
    var dir = targets[src];
    glob(src, function (er, files) {
      async.each(files, function (file, cb) {
        file = path.resolve('.', file);
        if (change && !_.contains(dependencies[file], change)) return;
        save(file, src, dir, cb);
      }, cb);
    });
  }, function () {
    if (config['export-fingerprints']) {
      var json = JSON.stringify(cogs.fingerprints, null, '  ');
      fs.writeFileSync(config['export-fingerprints'], json);
    }
    if (!config.watch) cogs.end();
  });
};

saveAll();

if (config.watch) {
  watchr.watch({
    ignoreHiddenFiles: true,
    ignorePaths: config['ignore-paths'] && config['ignore-paths'].split(','),
    ignoreCustomPatterns: config['ignore-basenames'] &&
      new RegExp(config['ignore-basenames'], 'i'),
    paths: _.map(config.watch, function (p) { return path.resolve(p); }),
    listener: saveAll
  });
}
