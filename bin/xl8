#!/usr/bin/env node

var optimist = require('optimist');
var argv = optimist
  .usage('Usage: $0 input [-o output][-p path][-w watch][-O options][-cvCg]')
  .options({
    output: {
      alias: 'o',
      type: 'string',
      desc: 'The output file. If not specified result is sent to stdout.'
    },
    path: {
      alias: 'p',
      'default': process.cwd(),
      type: 'string',
      desc: 'An environment path or comma-separated paths.'
    },
    options: {
      alias: 'O',
      type: 'string',
      desc: 'JSON for options to be passed to processors and compressors.'
    },
    compress: {
      alias: 'c',
      'default': false,
      type: 'boolean',
      desc: 'Compress using UglifyJS and CleanCss.'
    },
    watch: {
      alias: 'w',
      type: 'string',
      desc: 'A path or comma-separated paths to watch.'
    },
    verbose: {
      alias: 'v',
      'default': false,
      type: 'boolean',
      desc: 'Log build starts and completes in stdout.'
    },
    colors: {
      alias: 'C',
      'default': false,
      type: 'boolean',
      desc: 'Use colors in verbose logging.'
    },
    growl: {
      alias: 'g',
      'default': false,
      type: 'boolean',
      desc: 'Use growl notifications for build starts and completes.'
    }
  })
  .check(function () {
    if (!optimist.argv._[0]) throw new Error('Please specify an input file.');
  })
  .argv;

var colors = argv.colors ? require('colors').setTheme({
  info: 'grey',
  error: 'red',
  success: 'green'
}) : null;
var growl = argv.growl ? require('growl') : null;
var util = require('util');
var watchr = argv.watchr ? require('watchr') : null;
var xl8 = require('..');

var alert = function (title, message, type) {
  var name = 'xl8';
  var image = (function () {
    switch (type) {
    case 'success':
      return 'node_modules/mocha/images/ok.png';
    case 'error':
      return 'node_modules/mocha/images/error.png';
    }
  })();
  if (argv.growl) growl(message, {title: title, name: name, image: image});
  message =
    colors ?
    ('[' + name + '] ' + title.bold + ' ' + message)[type] :
    '[' + name + '] ' + title + ' ' + message;
  if (type === 'error') return util.error(message);
  if (argv.verbose) util.log(message);
};

var save = function () {
  var input = argv._[0];
  var output = argv.output;
  var start = new Date();
  alert(input, "Building...", 'info');
  var done = function (er) {
    if (er) return alert(er.asset ? er.asset.abs : input, er.message, 'error');
    var duration = (new Date() - start) / 1000;
    alert(output || 'stdout', 'Built in ' + duration + 's.', 'success');
  };
  if (output) return xl8.saveAs(input, output, done);
  xl8.asset(input, function (er, asset) {
    if (er) return done(er);
    asset.build(function (er) {
      if (er) return done(er);
      process.stdout.write(asset.toString());
      done();
    });
  });
};
xl8.addPaths(argv.path.split(','));
if (argv.options) {
  var options = JSON.parse(argv.options);
  for (var steps in options) {
    var val = options[steps];
    steps = steps.split('.');
    var obj = xl8;
    for (var i = 0, l = steps.length - 1; i < l; ++i) obj = obj[steps[i]];
    obj[steps[i]] = val;
  }
}
if (argv.compress) {
  xl8.compressors.js = new xl8.UglifyJs();
  xl8.compressors.css = new xl8.CleanCss();
}
save();
if (watchr) {
  watchr.watch({
    ignoreHiddenFiles: true,
    paths: argv.watch.split(','),
    listener: save
  });
}
